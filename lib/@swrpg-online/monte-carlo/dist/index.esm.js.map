{
  "version": 3,
  "sources": ["../node_modules/@swrpg-online/dice/src/types.ts", "../node_modules/@swrpg-online/dice/src/hints.ts", "../node_modules/@swrpg-online/dice/src/diceFaces.ts", "../node_modules/@swrpg-online/dice/src/dice.ts", "../node_modules/@swrpg-online/dice/src/pools.ts", "../src/MonteCarlo.ts"],
  "sourcesContent": ["export type DicePool = {\n  boostDice?: number;\n  abilityDice?: number;\n  proficiencyDice?: number;\n  setBackDice?: number;\n  difficultyDice?: number;\n  challengeDice?: number;\n  forceDice?: number;\n  // Automatic symbols added to the result (from talents, attachments, etc.)\n  automaticSuccesses?: number;\n  automaticFailures?: number;\n  automaticAdvantages?: number;\n  automaticThreats?: number;\n  automaticTriumphs?: number;\n  automaticDespairs?: number;\n  automaticLightSide?: number;\n  automaticDarkSide?: number;\n  // Dice upgrades and downgrades\n  upgradeAbility?: number; // Upgrades ability (green) to proficiency (yellow)\n  upgradeDifficulty?: number; // Upgrades difficulty (purple) to challenge (red)\n  downgradeProficiency?: number; // Downgrades proficiency (yellow) to ability (green)\n  downgradeChallenge?: number; // Downgrades challenge (red) to difficulty (purple)\n};\n\nexport type DiceResult = {\n  successes: number;\n  failures: number;\n  advantages: number;\n  threats: number;\n  triumphs: number;\n  despair: number;\n  lightSide: number;\n  darkSide: number;\n  hints?: string[];\n};\n\nexport type DieType =\n  | \"boost\"\n  | \"ability\"\n  | \"proficiency\"\n  | \"setback\"\n  | \"difficulty\"\n  | \"challenge\"\n  | \"force\";\n\nexport type DetailedDieResult = {\n  type: DieType;\n  roll: number;\n  result: DiceResult;\n};\n\nexport type RollResult = {\n  results: DetailedDieResult[];\n  summary: DiceResult;\n};\n\nexport const SYMBOLS = {\n  SUCCESS: \"SUCCESS\" as const,\n  FAILURE: \"FAILURE\" as const,\n  ADVANTAGE: \"ADVANTAGE\" as const,\n  THREAT: \"THREAT\" as const,\n  TRIUMPH: \"TRIUMPH\" as const,\n  DESPAIR: \"DESPAIR\" as const,\n  LIGHT: \"LIGHT\" as const,\n  DARK: \"DARK\" as const,\n} as const;\n\nexport type Symbol = keyof typeof SYMBOLS;\n\nexport type DieFaceSymbols = {\n  successes?: number;\n  failures?: number;\n  advantages?: number;\n  threats?: number;\n  triumphs?: number;\n  despairs?: number;\n  lightSide?: number;\n  darkSide?: number;\n};\n\nexport type BoostDieFace = 1 | 2 | 3 | 4 | 5 | 6;\nexport type SetbackDieFace = 1 | 2 | 3 | 4 | 5 | 6;\nexport type AbilityDieFace = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\nexport type DifficultyDieFace = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\nexport type ProficiencyDieFace =\n  | 1\n  | 2\n  | 3\n  | 4\n  | 5\n  | 6\n  | 7\n  | 8\n  | 9\n  | 10\n  | 11\n  | 12;\nexport type ChallengeDieFace = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\nexport type ForceDieFace = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;\n\nexport type RollOptions = {\n  hints?: boolean;\n  /**\n   * Maximum number of dice allowed per die type.\n   * Default: 100\n   */\n  maxDicePerType?: number;\n  /**\n   * Maximum total number of dice allowed in a single roll.\n   * Default: 500\n   */\n  maxTotalDice?: number;\n  /**\n   * Whether to throw an error when dice limits are exceeded.\n   * If false, dice counts will be silently capped to the maximum.\n   * Default: false\n   */\n  throwOnLimitExceeded?: boolean;\n};\n", "import { SYMBOLS, type Symbol } from \"./types\";\n\n// 1 advantage or 1 triumph\nconst recoverOneStrain = \"Recover one strain (may be applied more than once).\";\nconst addBoostDieToActiveAlly =\n  \"Add a boost die to the next allied active character's check.\";\nconst noticeImportantPoint =\n  \"Notice a single important point in the ongoing conflict, such as the location of a blast door's control panel or a weak point on an attack speeder.\";\nconst inflictCriticalInjury =\n  \"Inflict a Critical Injury with a successful attack that deals damage past soak (Advantage cost may vary).\";\nconst activateWeaponQuality =\n  \"Activate a weapon quality (Advantage cost may vary).\";\n\n// 2 advantage or 1 triumph\nconst performManeuver =\n  \"Perform an immediate free maneuver that does not exceed the two maneuver per turn limit.\";\nconst addSetbackDie =\n  \"Add a setback die to the targeted character's next check.\";\nconst addBoostDieToAnyAlly =\n  \"Add a boost die to any allied character's next check, including that of the active character.\";\n\n// 3 advantage or 1 triumph\nconst negateEnemy =\n  \"Negate the targeted enemy's defensive bonuses (such as the defense gained from cover, equipment, or performing the Guarded Stance maneuver) util the end of the current round.\";\nconst ignoreEnvironment =\n  \"Ignore penalizing environmental effects such as inclement weather, zero gravity, or similar circumstances until the end of the active character's next turn.\";\nconst disableOpponent =\n  \"When dealing damage to a target, have the attack disable the opponent or one piece of gear rather than dealing wounds or strain. This could include hobbling them temporarily with a shot to the leg, or disabling their comlink. This should be agreed upon by the player and the GM, and the effects are up to the GM (although Table 6-10: Critical Injury Result is a god resource to consult for possible effects). The effects should be temporary and not too excessive.\";\nconst gainDefense =\n  \"Gain + 1 melee or ranged defense until the end of the active character's next turn.\";\nconst dropWeapon =\n  \"Force the target to drop a melee or ranged weapon they are wielding.\";\n\n// 1 triumph\nconst upgradeDifficultyTargetedCharacter =\n  \"Upgrade the difficulty of the targeted character's next check.\";\nconst doSomethingVital =\n  \"Do something vital, such as shooting the controls to the nearby blast doors to seal them shut.\";\nconst upgradeAnyAllyCheck =\n  \"Upgrade any allied character's next check, including that of the current active character.\";\n\n// 2 triumph\nconst destroyEquipment =\n  \"When dealing damage to a target, have the attack destroy a piece of equipment the target is using, such as blowing up his blaster or destroying a personal shield generator.\";\n\n// 1 threat or 1 despair\nconst sufferStrain = \"The active character suffers 1 strain.\";\nconst loseManeuverBenefit =\n  \"The active character loses the benefits of a prior maneuver (such as from taking cover or assuming a Guarded Stance) until they perform the maneuver again.\";\n\n// 2 threat or 1 despair\nconst freeManeuver =\n  \"An opponent may immediately perform one free maneuver in response to the active character's check.\";\nconst addBoostDieToTargetedCharacter =\n  \"Add a boost die to the targeted character's next check.\";\nconst sufferSetback =\n  \"The active character or an allied character suffers a setback die on their next action.\";\n\n// 3 threat or 1 despair\nconst fallProne = \"The active character falls prone.\";\nconst gainSignificantAdvantage =\n  \"The active character grants the enemy a significant advantage in the ongoing encounter, such as accidentally blasting the controls to a bridge the active character was planning to use for their escape.\";\n\n// 1 despair\nconst outOfAmmo =\n  \"The character's ranged weapon imediately runs out of ammunition and may not be used for the remainder of the encounter.\";\nconst upgradeDifficultyAlliedCharacter =\n  \"Upgrade the difficulty of an allied character's next check, including that of the current active character.\";\nconst damagedItem =\n  \"The tool or melee weapon the character is using becomes damaged.\";\n\nexport type CostType = {\n  [key in Symbol]?: number;\n};\n\ntype Hint = {\n  description: string;\n  cost: CostType;\n};\n\nexport const hints: Hint[] = [\n  // 1 advantage or 1 triumph\n  {\n    description: recoverOneStrain,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: addBoostDieToActiveAlly,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: noticeImportantPoint,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: inflictCriticalInjury,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: activateWeaponQuality,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 1,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 2 advantage or 1 triumph\n  {\n    description: performManeuver,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 2,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: addSetbackDie,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 2,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: addBoostDieToAnyAlly,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 2,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 3 advantage or 1 triumph\n  {\n    description: negateEnemy,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: ignoreEnvironment,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: disableOpponent,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: gainDefense,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: dropWeapon,\n    cost: {\n      [SYMBOLS.ADVANTAGE]: 3,\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 1 triumph\n  {\n    description: upgradeDifficultyTargetedCharacter,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: doSomethingVital,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  {\n    description: upgradeAnyAllyCheck,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 1,\n    },\n  },\n  // 2 triumph\n  {\n    description: destroyEquipment,\n    cost: {\n      [SYMBOLS.TRIUMPH]: 2,\n    },\n  },\n  // 1 threat or 1 despair\n  {\n    description: sufferStrain,\n    cost: {\n      [SYMBOLS.THREAT]: 1,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: loseManeuverBenefit,\n    cost: {\n      [SYMBOLS.THREAT]: 1,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  // 2 threat or 1 despair\n  {\n    description: freeManeuver,\n    cost: {\n      [SYMBOLS.THREAT]: 2,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: addBoostDieToTargetedCharacter,\n    cost: {\n      [SYMBOLS.THREAT]: 1,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: sufferSetback,\n    cost: {\n      [SYMBOLS.THREAT]: 2,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  // 3 threat or 1 despair\n  {\n    description: fallProne,\n    cost: {\n      [SYMBOLS.THREAT]: 3,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: gainSignificantAdvantage,\n    cost: {\n      [SYMBOLS.THREAT]: 3,\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  // 1 despair\n  {\n    description: outOfAmmo,\n    cost: {\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: upgradeDifficultyAlliedCharacter,\n    cost: {\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n  {\n    description: damagedItem,\n    cost: {\n      [SYMBOLS.DESPAIR]: 1,\n    },\n  },\n];\n\nexport function hintCostDisplayText(hint: Hint): string {\n  if (!hint.cost || Object.keys(hint.cost).length === 0) {\n    return \"No cost\";\n  }\n  const parts = Object.entries(hint.cost)\n    .filter(([_, count]) => count && count > 0)\n    .map(([symbol, count]) => {\n      const symbolName =\n        symbol.charAt(0).toUpperCase() + symbol.toLowerCase().slice(1);\n      const plural = count > 1 ? \"s\" : \"\";\n      return `${count} ${symbolName}${plural}`;\n    });\n\n  // Use \"OR\" in uppercase for clarity when multiple options exist\n  if (parts.length > 1) {\n    return parts.join(\" OR \");\n  }\n  return parts.length > 0 ? parts[0] : \"No cost\";\n}\n", "import { DieFaceSymbols } from \"./types\";\n\nexport const BOOST_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: {}, // Blank\n  2: {}, // Blank\n  3: { successes: 1 }, // (S)\n  4: { successes: 1, advantages: 1 }, // (S)(A)\n  5: { advantages: 2 }, // (A)(A)\n  6: { advantages: 1 }, // (A)\n};\n\nexport const SETBACK_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: {}, // Blank\n  2: {}, // Blank\n  3: { failures: 1 }, // (F)\n  4: { failures: 1 }, // (F)\n  5: { threats: 1 }, // (TH)\n  6: { threats: 1 }, // (TH)\n};\n\nexport const ABILITY_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: {}, // Blank\n  2: { successes: 1 }, // (S)\n  3: { successes: 1 }, // (S)\n  4: { successes: 2 }, // (S)(S)\n  5: { advantages: 1 }, // (A)\n  6: { advantages: 1 }, // (A)\n  7: { successes: 1, advantages: 1 }, // (S)(A)\n  8: { advantages: 2 }, // (A)(A)\n};\n\nexport const DIFFICULTY_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: {}, // Blank\n  2: { failures: 1 }, // (F)\n  3: { failures: 2 }, // (F)(F)\n  4: { threats: 1 }, // (TH)\n  5: { threats: 1 }, // (TH)\n  6: { threats: 1 }, // (TH)\n  7: { threats: 2 }, // (TH)(TH)\n  8: { failures: 1, threats: 1 }, // (F)(TH)\n};\n\nexport const PROFICIENCY_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: {}, // Blank\n  2: { successes: 1 }, // (S)\n  3: { successes: 1 }, // (S)\n  4: { successes: 2 }, // (S)(S)\n  5: { successes: 2 }, // (S)(S)\n  6: { advantages: 1 }, // (A)\n  7: { successes: 1, advantages: 1 }, // (S)(A)\n  8: { successes: 1, advantages: 1 }, // (S)(A)\n  9: { successes: 1, advantages: 1 }, // (S)(A)\n  10: { advantages: 2 }, // (A)(A)\n  11: { successes: 1, advantages: 1 }, // (S)(A)\n  12: { triumphs: 1 }, // (TR) - Triumph also counts as Success\n};\n\nexport const CHALLENGE_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: {}, // Blank\n  2: { failures: 1 }, // (F)\n  3: { failures: 1 }, // (F)\n  4: { failures: 2 }, // (F)(F)\n  5: { failures: 2 }, // (F)(F)\n  6: { threats: 1 }, // (TH)\n  7: { threats: 1 }, // (TH)\n  8: { failures: 1, threats: 1 }, // (F)(TH)\n  9: { failures: 1, threats: 1 }, // (F)(TH)\n  10: { threats: 2 }, // (TH)(TH)\n  11: { threats: 2 }, // (TH)(TH)\n  12: { despairs: 1 }, // (D) - Despair also counts as Failure\n};\n\nexport const FORCE_DIE_FACES: Record<number, DieFaceSymbols> = {\n  1: { darkSide: 1 }, // (DS)\n  2: { darkSide: 1 }, // (DS)\n  3: { darkSide: 1 }, // (DS)\n  4: { darkSide: 1 }, // (DS)\n  5: { darkSide: 1 }, // (DS)\n  6: { darkSide: 1 }, // (DS)\n  7: { darkSide: 2 }, // (DS)(DS)\n  8: { lightSide: 1 }, // (LS)\n  9: { lightSide: 1 }, // (LS)\n  10: { lightSide: 2 }, // (LS)(LS)\n  11: { lightSide: 2 }, // (LS)(LS)\n  12: { lightSide: 2 }, // (LS)(LS)\n};\n\nexport const DICE_FACES = {\n  boost: BOOST_DIE_FACES,\n  setback: SETBACK_DIE_FACES,\n  ability: ABILITY_DIE_FACES,\n  difficulty: DIFFICULTY_DIE_FACES,\n  proficiency: PROFICIENCY_DIE_FACES,\n  challenge: CHALLENGE_DIE_FACES,\n  force: FORCE_DIE_FACES,\n} as const;\n", "import { hintCostDisplayText, hints } from \"./hints\";\nimport {\n  DicePool,\n  RollResult,\n  DiceResult,\n  DetailedDieResult,\n  RollOptions,\n} from \"./types\";\nimport {\n  BOOST_DIE_FACES,\n  SETBACK_DIE_FACES,\n  ABILITY_DIE_FACES,\n  DIFFICULTY_DIE_FACES,\n  PROFICIENCY_DIE_FACES,\n  CHALLENGE_DIE_FACES,\n  FORCE_DIE_FACES,\n} from \"./diceFaces\";\n\n// Default dice limits for performance and security\nexport const DEFAULT_MAX_DICE_PER_TYPE = 100;\nexport const DEFAULT_MAX_TOTAL_DICE = 500;\n\nconst rollDie = (sides: number): number =>\n  Math.floor(Math.random() * sides) + 1;\n\nconst boostDieResult = (roll: number): DiceResult => {\n  const face = BOOST_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\nconst setBackDieResult = (roll: number): DiceResult => {\n  const face = SETBACK_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\nconst abilityDieResult = (roll: number): DiceResult => {\n  const face = ABILITY_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\nconst difficultyDieResult = (roll: number): DiceResult => {\n  const face = DIFFICULTY_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\nconst proficiencyDieResult = (roll: number): DiceResult => {\n  const face = PROFICIENCY_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\nconst challengeDieResult = (roll: number): DiceResult => {\n  const face = CHALLENGE_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\nconst forceDieResult = (roll: number): DiceResult => {\n  const face = FORCE_DIE_FACES[roll];\n  return {\n    successes: face.successes || 0,\n    failures: face.failures || 0,\n    advantages: face.advantages || 0,\n    threats: face.threats || 0,\n    triumphs: face.triumphs || 0,\n    despair: face.despairs || 0,\n    lightSide: face.lightSide || 0,\n    darkSide: face.darkSide || 0,\n  };\n};\n\n/**\n * Applies dice upgrades and downgrades to a pool.\n * Upgrades are applied first, then downgrades.\n *\n * @param pool - The dice pool to modify\n * @returns A new dice pool with upgrades/downgrades applied\n */\nconst applyDiceModifications = (pool: DicePool): DicePool => {\n  const modifiedPool = { ...pool };\n\n  // Apply upgrades first (per game rules)\n  if (pool.upgradeAbility && pool.upgradeAbility > 0) {\n    let upgradesToApply = pool.upgradeAbility;\n    const currentAbility = modifiedPool.abilityDice || 0;\n\n    // Upgrade existing ability dice to proficiency\n    const upgradedDice = Math.min(currentAbility, upgradesToApply);\n    modifiedPool.abilityDice = currentAbility - upgradedDice;\n    modifiedPool.proficiencyDice =\n      (modifiedPool.proficiencyDice || 0) + upgradedDice;\n    upgradesToApply -= upgradedDice;\n\n    // Add remaining upgrades as new proficiency dice\n    if (upgradesToApply > 0) {\n      modifiedPool.proficiencyDice =\n        (modifiedPool.proficiencyDice || 0) + upgradesToApply;\n    }\n  }\n\n  if (pool.upgradeDifficulty && pool.upgradeDifficulty > 0) {\n    let upgradesToApply = pool.upgradeDifficulty;\n    const currentDifficulty = modifiedPool.difficultyDice || 0;\n\n    // Upgrade existing difficulty dice to challenge\n    const upgradedDice = Math.min(currentDifficulty, upgradesToApply);\n    modifiedPool.difficultyDice = currentDifficulty - upgradedDice;\n    modifiedPool.challengeDice =\n      (modifiedPool.challengeDice || 0) + upgradedDice;\n    upgradesToApply -= upgradedDice;\n\n    // Add remaining upgrades as new challenge dice\n    if (upgradesToApply > 0) {\n      modifiedPool.challengeDice =\n        (modifiedPool.challengeDice || 0) + upgradesToApply;\n    }\n  }\n\n  // Apply downgrades after upgrades\n  if (pool.downgradeProficiency && pool.downgradeProficiency > 0) {\n    const currentProficiency = modifiedPool.proficiencyDice || 0;\n    const downgradesToApply = Math.min(\n      currentProficiency,\n      pool.downgradeProficiency,\n    );\n\n    // Downgrade proficiency dice to ability dice\n    modifiedPool.proficiencyDice = currentProficiency - downgradesToApply;\n    modifiedPool.abilityDice =\n      (modifiedPool.abilityDice || 0) + downgradesToApply;\n    // Excess downgrades are ignored (per requirements)\n  }\n\n  if (pool.downgradeChallenge && pool.downgradeChallenge > 0) {\n    const currentChallenge = modifiedPool.challengeDice || 0;\n    const downgradesToApply = Math.min(\n      currentChallenge,\n      pool.downgradeChallenge,\n    );\n\n    // Downgrade challenge dice to difficulty dice\n    modifiedPool.challengeDice = currentChallenge - downgradesToApply;\n    modifiedPool.difficultyDice =\n      (modifiedPool.difficultyDice || 0) + downgradesToApply;\n    // Excess downgrades are ignored (per requirements)\n  }\n\n  return modifiedPool;\n};\n\nconst sumResults = (\n  results: DiceResult[],\n  automaticSymbols?: {\n    successes?: number;\n    failures?: number;\n    advantages?: number;\n    threats?: number;\n    triumphs?: number;\n    despairs?: number;\n    lightSide?: number;\n    darkSide?: number;\n  },\n  options?: RollOptions,\n): DiceResult => {\n  const sums = results.reduce(\n    (acc, curr) => ({\n      successes: acc.successes + curr.successes + curr.triumphs,\n      failures: acc.failures + curr.failures + curr.despair,\n      advantages: acc.advantages + curr.advantages,\n      threats: acc.threats + curr.threats,\n      triumphs: acc.triumphs + curr.triumphs,\n      despair: acc.despair + curr.despair,\n      lightSide: acc.lightSide + (curr.lightSide || 0),\n      darkSide: acc.darkSide + (curr.darkSide || 0),\n    }),\n    {\n      successes:\n        (automaticSymbols?.successes || 0) + (automaticSymbols?.triumphs || 0),\n      failures:\n        (automaticSymbols?.failures || 0) + (automaticSymbols?.despairs || 0),\n      advantages: automaticSymbols?.advantages || 0,\n      threats: automaticSymbols?.threats || 0,\n      triumphs: automaticSymbols?.triumphs || 0,\n      despair: automaticSymbols?.despairs || 0,\n      lightSide: automaticSymbols?.lightSide || 0,\n      darkSide: automaticSymbols?.darkSide || 0,\n    },\n  );\n\n  let netSuccesses = 0;\n  let netFailures = 0;\n\n  if (sums.successes === sums.failures) {\n    netSuccesses = 0;\n    netFailures = 0;\n  } else if (sums.successes > sums.failures) {\n    netSuccesses = sums.successes - sums.failures;\n  } else {\n    netFailures = sums.failures - sums.successes;\n  }\n\n  // Advantages and threats cancel each other out\n  let netAdvantages = 0;\n  let netThreats = 0;\n\n  if (sums.advantages === sums.threats) {\n    netAdvantages = 0;\n    netThreats = 0;\n  } else if (sums.advantages > sums.threats) {\n    netAdvantages = sums.advantages - sums.threats;\n  } else {\n    netThreats = sums.threats - sums.advantages;\n  }\n\n  const result: DiceResult = {\n    successes: netSuccesses,\n    failures: netFailures,\n    advantages: netAdvantages,\n    threats: netThreats,\n    triumphs: sums.triumphs,\n    despair: sums.despair,\n    lightSide: sums.lightSide,\n    darkSide: sums.darkSide,\n  };\n\n  return result;\n};\n\n/**\n * Rolls a dice pool and returns the results.\n *\n * @param pool - The dice pool to roll\n * @param options - Optional roll configuration including dice limits\n * @returns The roll results with detailed die information and summary\n * @throws {Error} If dice counts exceed configured limits\n *\n * Default limits:\n * - Max dice per type: 100 (configurable via options.maxDicePerType)\n * - Max total dice: 500 (configurable via options.maxTotalDice)\n */\nexport const roll = (pool: DicePool, options?: RollOptions): RollResult => {\n  // Apply dice modifications (upgrades/downgrades)\n  const modifiedPool = applyDiceModifications(pool);\n\n  const boostCount = modifiedPool.boostDice ?? 0;\n  const abilityCount = modifiedPool.abilityDice ?? 0;\n  const proficiencyCount = modifiedPool.proficiencyDice ?? 0;\n  const setBackCount = modifiedPool.setBackDice ?? 0;\n  const difficultyCount = modifiedPool.difficultyDice ?? 0;\n  const challengeCount = modifiedPool.challengeDice ?? 0;\n  const forceCount = modifiedPool.forceDice ?? 0;\n\n  // Get limits from options or use defaults\n  const maxDicePerType = options?.maxDicePerType ?? DEFAULT_MAX_DICE_PER_TYPE;\n  const maxTotalDice = options?.maxTotalDice ?? DEFAULT_MAX_TOTAL_DICE;\n\n  // Ensure all dice counts are non-negative and apply per-type limits\n  const sanitizedPool = {\n    boostDice: Math.max(0, Math.min(boostCount, maxDicePerType)),\n    abilityDice: Math.max(0, Math.min(abilityCount, maxDicePerType)),\n    proficiencyDice: Math.max(0, Math.min(proficiencyCount, maxDicePerType)),\n    setBackDice: Math.max(0, Math.min(setBackCount, maxDicePerType)),\n    difficultyDice: Math.max(0, Math.min(difficultyCount, maxDicePerType)),\n    challengeDice: Math.max(0, Math.min(challengeCount, maxDicePerType)),\n    forceDice: Math.max(0, Math.min(forceCount, maxDicePerType)),\n  };\n\n  // Check if any dice counts exceeded the per-type limit\n  const exceedsPerTypeLimit =\n    boostCount > maxDicePerType ||\n    abilityCount > maxDicePerType ||\n    proficiencyCount > maxDicePerType ||\n    setBackCount > maxDicePerType ||\n    difficultyCount > maxDicePerType ||\n    challengeCount > maxDicePerType ||\n    forceCount > maxDicePerType;\n\n  // Calculate total dice count\n  const totalDice =\n    sanitizedPool.boostDice +\n    sanitizedPool.abilityDice +\n    sanitizedPool.proficiencyDice +\n    sanitizedPool.setBackDice +\n    sanitizedPool.difficultyDice +\n    sanitizedPool.challengeDice +\n    sanitizedPool.forceDice;\n\n  // Check total dice limit\n  if (totalDice > maxTotalDice) {\n    throw new Error(\n      `Total dice count (${totalDice}) exceeds maximum allowed (${maxTotalDice}). ` +\n        `Please reduce the number of dice in your pool.`,\n    );\n  }\n\n  // Warn if per-type limits were exceeded (but continue with capped values)\n  if (exceedsPerTypeLimit && options?.throwOnLimitExceeded) {\n    const exceeded = [];\n    if (boostCount > maxDicePerType) exceeded.push(`boost: ${boostCount}`);\n    if (abilityCount > maxDicePerType)\n      exceeded.push(`ability: ${abilityCount}`);\n    if (proficiencyCount > maxDicePerType)\n      exceeded.push(`proficiency: ${proficiencyCount}`);\n    if (setBackCount > maxDicePerType)\n      exceeded.push(`setback: ${setBackCount}`);\n    if (difficultyCount > maxDicePerType)\n      exceeded.push(`difficulty: ${difficultyCount}`);\n    if (challengeCount > maxDicePerType)\n      exceeded.push(`challenge: ${challengeCount}`);\n    if (forceCount > maxDicePerType) exceeded.push(`force: ${forceCount}`);\n\n    throw new Error(\n      `Dice counts exceed per-type limit (${maxDicePerType}): ${exceeded.join(\", \")}. ` +\n        `Dice counts have been capped to the maximum.`,\n    );\n  }\n\n  const detailedResults: DetailedDieResult[] = [];\n\n  // Roll boost dice\n  for (let i = 0; i < sanitizedPool.boostDice; i++) {\n    const roll = rollDie(6);\n    detailedResults.push({\n      type: \"boost\",\n      roll,\n      result: boostDieResult(roll),\n    });\n  }\n\n  // Roll ability dice\n  for (let i = 0; i < sanitizedPool.abilityDice; i++) {\n    const roll = rollDie(8);\n    detailedResults.push({\n      type: \"ability\",\n      roll,\n      result: abilityDieResult(roll),\n    });\n  }\n\n  // Roll proficiency dice\n  for (let i = 0; i < sanitizedPool.proficiencyDice; i++) {\n    const roll = rollDie(12);\n    detailedResults.push({\n      type: \"proficiency\",\n      roll,\n      result: proficiencyDieResult(roll),\n    });\n  }\n\n  // Roll setback dice\n  for (let i = 0; i < sanitizedPool.setBackDice; i++) {\n    const roll = rollDie(6);\n    detailedResults.push({\n      type: \"setback\",\n      roll,\n      result: setBackDieResult(roll),\n    });\n  }\n\n  // Roll difficulty dice\n  for (let i = 0; i < sanitizedPool.difficultyDice; i++) {\n    const roll = rollDie(8);\n    detailedResults.push({\n      type: \"difficulty\",\n      roll,\n      result: difficultyDieResult(roll),\n    });\n  }\n\n  // Roll challenge dice\n  for (let i = 0; i < sanitizedPool.challengeDice; i++) {\n    const roll = rollDie(12);\n    detailedResults.push({\n      type: \"challenge\",\n      roll,\n      result: challengeDieResult(roll),\n    });\n  }\n\n  // Roll force dice\n  for (let i = 0; i < sanitizedPool.forceDice; i++) {\n    const roll = rollDie(12);\n    detailedResults.push({\n      type: \"force\",\n      roll,\n      result: forceDieResult(roll),\n    });\n  }\n\n  const automaticSymbols = {\n    successes: pool.automaticSuccesses,\n    failures: pool.automaticFailures,\n    advantages: pool.automaticAdvantages,\n    threats: pool.automaticThreats,\n    triumphs: pool.automaticTriumphs,\n    despairs: pool.automaticDespairs,\n    lightSide: pool.automaticLightSide,\n    darkSide: pool.automaticDarkSide,\n  };\n\n  const summary = sumResults(\n    detailedResults.map((r) => r.result),\n    automaticSymbols,\n    options,\n  );\n\n  if (options?.hints) {\n    const applicableHints = hints.filter((hint) => {\n      const { cost } = hint;\n      // For OR conditions: at least one option must be fully satisfied\n      // Each entry in cost represents an alternative way to pay for the hint\n      return Object.entries(cost).some(([symbol, required]) => {\n        const summaryKey = (symbol.toLowerCase() + \"s\") as keyof typeof summary;\n        const value = summary[summaryKey];\n        if (typeof value !== \"number\") return false;\n        // Check if we have enough of this symbol type to afford the hint\n        return required !== undefined && required > 0 && value >= required;\n      });\n    });\n    summary.hints = applicableHints.map(\n      (hint) => `${hintCostDisplayText(hint)} - ${hint.description}`,\n    );\n  }\n\n  return {\n    results: detailedResults,\n    summary: summary,\n  };\n};\n", "import { DicePool } from \"./types\";\n\n/**\n * Options for applying talent or equipment modifiers to a dice pool\n */\nexport type PoolModifiers = {\n  automaticSuccesses?: number;\n  automaticFailures?: number;\n  automaticAdvantages?: number;\n  automaticThreats?: number;\n  automaticTriumphs?: number;\n  automaticDespairs?: number;\n  upgradeAbility?: number;\n  upgradeDifficulty?: number;\n  downgradeProficiency?: number;\n  downgradeChallenge?: number;\n};\n\n/**\n * Creates a basic skill check dice pool\n * @param ability Number of ability (green) dice\n * @param proficiency Number of proficiency (yellow) dice\n * @param modifiers Optional modifiers from talents, equipment, etc.\n * @returns DicePool configured for a basic skill check\n */\nexport const createSkillCheck = (\n  ability: number,\n  proficiency: number,\n  modifiers?: PoolModifiers,\n): DicePool => ({\n  abilityDice: Math.max(0, ability),\n  proficiencyDice: Math.max(0, proficiency),\n  ...modifiers,\n});\n\n/**\n * Creates a combat check dice pool with optional boost die\n * @param ability Number of ability (green) dice\n * @param proficiency Number of proficiency (yellow) dice\n * @param boost Number of boost (blue) dice\n * @param modifiers Optional modifiers from talents, equipment, etc.\n * @returns DicePool configured for a combat check\n */\nexport const createCombatCheck = (\n  ability: number,\n  proficiency: number,\n  boost: number = 0,\n  modifiers?: PoolModifiers,\n): DicePool => ({\n  abilityDice: Math.max(0, ability),\n  proficiencyDice: Math.max(0, proficiency),\n  boostDice: Math.max(0, boost),\n  ...modifiers,\n});\n\n/**\n * Creates an opposed check dice pool\n * @param ability Number of ability (green) dice\n * @param proficiency Number of proficiency (yellow) dice\n * @param difficulty Number of difficulty (purple) dice\n * @param challenge Number of challenge (red) dice\n * @param modifiers Optional modifiers from talents, equipment, etc.\n * @returns DicePool configured for an opposed check\n */\nexport const createOpposedCheck = (\n  ability: number,\n  proficiency: number,\n  difficulty: number,\n  challenge: number = 0,\n  modifiers?: PoolModifiers,\n): DicePool => ({\n  abilityDice: Math.max(0, ability),\n  proficiencyDice: Math.max(0, proficiency),\n  difficultyDice: Math.max(0, difficulty),\n  challengeDice: Math.max(0, challenge),\n  ...modifiers,\n});\n\n/**\n * Creates a difficulty check dice pool\n * @param difficulty Number of difficulty (purple) dice\n * @param challenge Number of challenge (red) dice\n * @param modifiers Optional modifiers from talents, equipment, etc.\n * @returns DicePool configured for a pure difficulty check\n */\nexport const createDifficultyPool = (\n  difficulty: number,\n  challenge: number = 0,\n  modifiers?: PoolModifiers,\n): DicePool => ({\n  difficultyDice: Math.max(0, difficulty),\n  challengeDice: Math.max(0, challenge),\n  ...modifiers,\n});\n\n/**\n * Applies talent modifiers to an existing dice pool\n * Common use case for talents that add automatic advantages, successes, or upgrade dice\n * @param pool The base dice pool\n * @param modifiers The modifiers to apply\n * @returns A new dice pool with modifiers applied\n */\nexport const applyTalentModifiers = (\n  pool: DicePool,\n  modifiers: PoolModifiers,\n): DicePool => ({\n  ...pool,\n  automaticSuccesses:\n    (pool.automaticSuccesses || 0) + (modifiers.automaticSuccesses || 0),\n  automaticFailures:\n    (pool.automaticFailures || 0) + (modifiers.automaticFailures || 0),\n  automaticAdvantages:\n    (pool.automaticAdvantages || 0) + (modifiers.automaticAdvantages || 0),\n  automaticThreats:\n    (pool.automaticThreats || 0) + (modifiers.automaticThreats || 0),\n  automaticTriumphs:\n    (pool.automaticTriumphs || 0) + (modifiers.automaticTriumphs || 0),\n  automaticDespairs:\n    (pool.automaticDespairs || 0) + (modifiers.automaticDespairs || 0),\n  upgradeAbility: (pool.upgradeAbility || 0) + (modifiers.upgradeAbility || 0),\n  upgradeDifficulty:\n    (pool.upgradeDifficulty || 0) + (modifiers.upgradeDifficulty || 0),\n  downgradeProficiency:\n    (pool.downgradeProficiency || 0) + (modifiers.downgradeProficiency || 0),\n  downgradeChallenge:\n    (pool.downgradeChallenge || 0) + (modifiers.downgradeChallenge || 0),\n});\n", "import { DicePool, roll } from \"@swrpg-online/dice\";\nimport { DiceResult } from \"@swrpg-online/dice/dist/types\";\n\nexport { DicePool };\n\nexport interface ModifierConfig {\n  automaticSuccesses?: number;\n  automaticFailures?: number;\n  automaticAdvantages?: number;\n  automaticThreats?: number;\n  automaticTriumphs?: number;\n  automaticDespairs?: number;\n  automaticLightSide?: number;\n  automaticDarkSide?: number;\n  upgradeAbility?: number;\n  upgradeDifficulty?: number;\n  downgradeProficiency?: number;\n  downgradeChallenge?: number;\n}\n\nexport interface SimulationConfig {\n  dicePool: DicePool;\n  iterations?: number;\n  modifiers?: ModifierConfig;\n  playerModifiers?: ModifierConfig;\n  oppositionModifiers?: ModifierConfig;\n}\n\nexport interface ModifierAnalysis {\n  automaticSymbolContribution: {\n    successes: number;\n    failures: number;\n    advantages: number;\n    threats: number;\n    triumphs: number;\n    despairs: number;\n    lightSide: number;\n    darkSide: number;\n  };\n  rolledSymbolContribution: {\n    successes: number;\n    failures: number;\n    advantages: number;\n    threats: number;\n    triumphs: number;\n    despairs: number;\n    lightSide: number;\n    darkSide: number;\n  };\n  upgradeImpact: {\n    abilityUpgrades: number;\n    difficultyUpgrades: number;\n    proficiencyDowngrades: number;\n    challengeDowngrades: number;\n  };\n}\n\nexport class MonteCarloError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"MonteCarloError\";\n  }\n}\n\nexport interface HistogramData {\n  netSuccesses: { [key: number]: number };\n  netAdvantages: { [key: number]: number };\n  triumphs: { [key: number]: number };\n  despairs: { [key: number]: number };\n  lightSide: { [key: number]: number };\n  darkSide: { [key: number]: number };\n}\n\nexport interface DistributionAnalysis {\n  skewness: number;\n  kurtosis: number;\n  outliers: number[];\n  modes: number[];\n  percentiles: {\n    [key: number]: number; // key: percentile (0-100), value: threshold\n  };\n}\n\nexport interface MonteCarloResult {\n  averages: DiceResult;\n  medians: DiceResult;\n  standardDeviations: DiceResult;\n  successProbability: number;\n  criticalSuccessProbability: number;\n  criticalFailureProbability: number;\n  netPositiveProbability: number;\n  histogram: HistogramData;\n  analysis: {\n    netSuccesses: DistributionAnalysis;\n    netAdvantages: DistributionAnalysis;\n    triumphs: DistributionAnalysis;\n    despairs: DistributionAnalysis;\n    lightSide: DistributionAnalysis;\n    darkSide: DistributionAnalysis;\n  };\n  modifierAnalysis?: ModifierAnalysis;\n}\n\nexport class MonteCarlo {\n  private readonly dicePool: DicePool;\n  private readonly iterations: number;\n  private readonly modifiers?: ModifierConfig;\n  private readonly config?: SimulationConfig;\n  private histogram: HistogramData = {\n    netSuccesses: {},\n    netAdvantages: {},\n    triumphs: {},\n    despairs: {},\n    lightSide: {},\n    darkSide: {},\n  };\n  private static readonly MIN_ITERATIONS = 100;\n  private static readonly MAX_ITERATIONS = 1000000;\n  private statsCache: Map<string, number> = new Map();\n  private modifierStats: ModifierAnalysis = {\n    automaticSymbolContribution: {\n      successes: 0,\n      failures: 0,\n      advantages: 0,\n      threats: 0,\n      triumphs: 0,\n      despairs: 0,\n      lightSide: 0,\n      darkSide: 0,\n    },\n    rolledSymbolContribution: {\n      successes: 0,\n      failures: 0,\n      advantages: 0,\n      threats: 0,\n      triumphs: 0,\n      despairs: 0,\n      lightSide: 0,\n      darkSide: 0,\n    },\n    upgradeImpact: {\n      abilityUpgrades: 0,\n      difficultyUpgrades: 0,\n      proficiencyDowngrades: 0,\n      challengeDowngrades: 0,\n    },\n  };\n  private runningStats: {\n    successCount: number;\n    criticalSuccessCount: number;\n    criticalFailureCount: number;\n    netPositiveCount: number;\n    sumSuccesses: number;\n    sumAdvantages: number;\n    sumTriumphs: number;\n    sumFailures: number;\n    sumThreats: number;\n    sumDespair: number;\n    sumLightSide: number;\n    sumDarkSide: number;\n    sumSquaredSuccesses: number;\n    sumSquaredAdvantages: number;\n    sumSquaredThreats: number;\n    sumSquaredFailures: number;\n    sumSquaredDespair: number;\n    sumSquaredLightSide: number;\n    sumSquaredDarkSide: number;\n    sumSquaredTriumphs: number;\n  } = {\n    successCount: 0,\n    criticalSuccessCount: 0,\n    criticalFailureCount: 0,\n    netPositiveCount: 0,\n    sumSuccesses: 0,\n    sumAdvantages: 0,\n    sumTriumphs: 0,\n    sumFailures: 0,\n    sumThreats: 0,\n    sumDespair: 0,\n    sumLightSide: 0,\n    sumDarkSide: 0,\n    sumSquaredSuccesses: 0,\n    sumSquaredAdvantages: 0,\n    sumSquaredThreats: 0,\n    sumSquaredFailures: 0,\n    sumSquaredDespair: 0,\n    sumSquaredLightSide: 0,\n    sumSquaredDarkSide: 0,\n    sumSquaredTriumphs: 0,\n  };\n  private results: DiceResult[] = [];\n\n  constructor(\n    dicePoolOrConfig: DicePool | SimulationConfig,\n    iterations: number = 10000,\n    runSimulate: boolean = true,\n  ) {\n    if (this.isSimulationConfig(dicePoolOrConfig)) {\n      this.config = dicePoolOrConfig;\n      this.dicePool = dicePoolOrConfig.dicePool;\n      this.iterations = dicePoolOrConfig.iterations || iterations;\n      this.modifiers =\n        dicePoolOrConfig.modifiers ||\n        this.mergeModifiers(\n          dicePoolOrConfig.playerModifiers,\n          dicePoolOrConfig.oppositionModifiers,\n        );\n    } else {\n      this.dicePool = dicePoolOrConfig;\n      this.iterations = iterations;\n    }\n\n    this.validateDicePool(this.dicePool);\n    this.validateIterations(this.iterations);\n    this.resetRunningStats();\n    if (runSimulate) {\n      this.simulate();\n    }\n  }\n\n  private isSimulationConfig(obj: any): obj is SimulationConfig {\n    return obj && typeof obj === \"object\" && \"dicePool\" in obj;\n  }\n\n  private mergeModifiers(\n    player?: ModifierConfig,\n    opposition?: ModifierConfig,\n  ): ModifierConfig | undefined {\n    if (!player && !opposition) return undefined;\n\n    const merged: ModifierConfig = {};\n\n    if (player) {\n      merged.automaticSuccesses = player.automaticSuccesses;\n      merged.automaticAdvantages = player.automaticAdvantages;\n      merged.automaticTriumphs = player.automaticTriumphs;\n      merged.automaticLightSide = player.automaticLightSide;\n      merged.upgradeAbility = player.upgradeAbility;\n      merged.downgradeProficiency = player.downgradeProficiency;\n    }\n\n    if (opposition) {\n      merged.automaticFailures = opposition.automaticFailures;\n      merged.automaticThreats = opposition.automaticThreats;\n      merged.automaticDespairs = opposition.automaticDespairs;\n      merged.automaticDarkSide = opposition.automaticDarkSide;\n      merged.upgradeDifficulty = opposition.upgradeDifficulty;\n      merged.downgradeChallenge = opposition.downgradeChallenge;\n    }\n\n    return merged;\n  }\n\n  private applyModifiers(pool: DicePool): DicePool {\n    if (!this.modifiers) return pool;\n\n    const modifiedPool: DicePool = { ...pool };\n\n    // Apply automatic symbols\n    if (this.modifiers.automaticSuccesses)\n      modifiedPool.automaticSuccesses =\n        (modifiedPool.automaticSuccesses || 0) +\n        this.modifiers.automaticSuccesses;\n    if (this.modifiers.automaticFailures)\n      modifiedPool.automaticFailures =\n        (modifiedPool.automaticFailures || 0) +\n        this.modifiers.automaticFailures;\n    if (this.modifiers.automaticAdvantages)\n      modifiedPool.automaticAdvantages =\n        (modifiedPool.automaticAdvantages || 0) +\n        this.modifiers.automaticAdvantages;\n    if (this.modifiers.automaticThreats)\n      modifiedPool.automaticThreats =\n        (modifiedPool.automaticThreats || 0) + this.modifiers.automaticThreats;\n    if (this.modifiers.automaticTriumphs)\n      modifiedPool.automaticTriumphs =\n        (modifiedPool.automaticTriumphs || 0) +\n        this.modifiers.automaticTriumphs;\n    if (this.modifiers.automaticDespairs)\n      modifiedPool.automaticDespairs =\n        (modifiedPool.automaticDespairs || 0) +\n        this.modifiers.automaticDespairs;\n    if (this.modifiers.automaticLightSide)\n      modifiedPool.automaticLightSide =\n        (modifiedPool.automaticLightSide || 0) +\n        this.modifiers.automaticLightSide;\n    if (this.modifiers.automaticDarkSide)\n      modifiedPool.automaticDarkSide =\n        (modifiedPool.automaticDarkSide || 0) +\n        this.modifiers.automaticDarkSide;\n\n    // Apply upgrades/downgrades\n    if (this.modifiers.upgradeAbility)\n      modifiedPool.upgradeAbility =\n        (modifiedPool.upgradeAbility || 0) + this.modifiers.upgradeAbility;\n    if (this.modifiers.upgradeDifficulty)\n      modifiedPool.upgradeDifficulty =\n        (modifiedPool.upgradeDifficulty || 0) +\n        this.modifiers.upgradeDifficulty;\n    if (this.modifiers.downgradeProficiency)\n      modifiedPool.downgradeProficiency =\n        (modifiedPool.downgradeProficiency || 0) +\n        this.modifiers.downgradeProficiency;\n    if (this.modifiers.downgradeChallenge)\n      modifiedPool.downgradeChallenge =\n        (modifiedPool.downgradeChallenge || 0) +\n        this.modifiers.downgradeChallenge;\n\n    // Track upgrades for analysis\n    this.modifierStats.upgradeImpact.abilityUpgrades =\n      this.modifiers.upgradeAbility || 0;\n    this.modifierStats.upgradeImpact.difficultyUpgrades =\n      this.modifiers.upgradeDifficulty || 0;\n    this.modifierStats.upgradeImpact.proficiencyDowngrades =\n      this.modifiers.downgradeProficiency || 0;\n    this.modifierStats.upgradeImpact.challengeDowngrades =\n      this.modifiers.downgradeChallenge || 0;\n\n    return modifiedPool;\n  }\n\n  private validateDicePool(dicePool: DicePool): void {\n    if (!dicePool || typeof dicePool !== \"object\") {\n      throw new MonteCarloError(\n        \"Invalid dice pool: must be a valid DicePool object\",\n      );\n    }\n\n    const diceTypes = [\n      \"abilityDice\",\n      \"proficiencyDice\",\n      \"boostDice\",\n      \"setBackDice\",\n      \"difficultyDice\",\n      \"challengeDice\",\n      \"forceDice\",\n    ];\n\n    // Check if at least one die type is present\n    const hasAnyDice = diceTypes.some(\n      (type) =>\n        dicePool[type as keyof DicePool] &&\n        dicePool[type as keyof DicePool]! > 0,\n    );\n\n    if (!hasAnyDice) {\n      throw new MonteCarloError(\n        \"Invalid dice pool: must contain at least one die\",\n      );\n    }\n\n    // Validate each die count is non-negative\n    diceTypes.forEach((type) => {\n      const count = dicePool[type as keyof DicePool];\n      if (count !== undefined && (count < 0 || !Number.isInteger(count))) {\n        throw new MonteCarloError(\n          `Invalid ${type}: must be a non-negative integer`,\n        );\n      }\n    });\n  }\n\n  private validateIterations(iterations: number): void {\n    if (!Number.isInteger(iterations)) {\n      throw new MonteCarloError(\"Iterations must be an integer\");\n    }\n    if (iterations < MonteCarlo.MIN_ITERATIONS) {\n      throw new MonteCarloError(\n        `Iterations must be at least ${MonteCarlo.MIN_ITERATIONS}`,\n      );\n    }\n    if (iterations > MonteCarlo.MAX_ITERATIONS) {\n      throw new MonteCarloError(\n        `Iterations must not exceed ${MonteCarlo.MAX_ITERATIONS}`,\n      );\n    }\n  }\n\n  private calculateHistogramStats(\n    histogram: { [key: number]: number },\n    totalCount: number,\n  ): {\n    mean: number;\n    stdDev: number;\n    sum: number;\n    sumSquares: number;\n  } {\n    let sum = 0;\n    let sumSquares = 0;\n    let count = 0;\n\n    // Single pass to calculate sum and sum of squares\n    for (const [value, freq] of Object.entries(histogram)) {\n      const val = parseInt(value);\n      sum += val * freq;\n      sumSquares += val * val * freq;\n      count += freq;\n    }\n\n    const mean = sum / count;\n    const variance = sumSquares / count - mean * mean;\n    const stdDev = Math.sqrt(Math.max(0, variance)); // Avoid negative values due to floating point errors\n\n    return { mean, stdDev, sum, sumSquares };\n  }\n\n  private calculateSkewness(\n    histogram: { [key: number]: number },\n    stats: { mean: number; stdDev: number },\n  ): number {\n    if (stats.stdDev === 0) return 0;\n\n    let sumCubedDeviations = 0;\n    let totalCount = 0;\n\n    for (const [value, freq] of Object.entries(histogram)) {\n      const deviation = (parseInt(value) - stats.mean) / stats.stdDev;\n      sumCubedDeviations += Math.pow(deviation, 3) * freq;\n      totalCount += freq;\n    }\n\n    return sumCubedDeviations / totalCount;\n  }\n\n  private calculateKurtosis(\n    histogram: { [key: number]: number },\n    stats: { mean: number; stdDev: number },\n  ): number {\n    if (stats.stdDev === 0) return 0;\n\n    let sumFourthPowerDeviations = 0;\n    let totalCount = 0;\n\n    for (const [value, freq] of Object.entries(histogram)) {\n      const deviation = (parseInt(value) - stats.mean) / stats.stdDev;\n      sumFourthPowerDeviations += Math.pow(deviation, 4) * freq;\n      totalCount += freq;\n    }\n\n    return sumFourthPowerDeviations / totalCount - 3;\n  }\n\n  private findOutliers(\n    histogram: { [key: number]: number },\n    stats: { mean: number; stdDev: number },\n  ): number[] {\n    if (stats.stdDev === 0) return [];\n    const threshold = 2;\n    return Object.entries(histogram)\n      .filter(\n        ([value]) =>\n          Math.abs(parseInt(value) - stats.mean) > threshold * stats.stdDev,\n      )\n      .map(([value]) => parseInt(value));\n  }\n\n  private analyzeDistribution(\n    histogram: { [key: number]: number },\n    totalCount: number,\n  ): DistributionAnalysis {\n    // Calculate basic statistics in a single pass\n    const stats = this.calculateHistogramStats(histogram, totalCount);\n\n    return {\n      skewness: this.calculateSkewness(histogram, stats),\n      kurtosis: this.calculateKurtosis(histogram, stats),\n      outliers: this.findOutliers(histogram, stats),\n      modes: this.findModes(histogram),\n      percentiles: this.calculatePercentiles(histogram, totalCount),\n    };\n  }\n\n  private average(\n    selector: ((roll: DiceResult) => number) | { name: string },\n  ): number {\n    const selectorName =\n      typeof selector === \"function\"\n        ? selector.name || \"custom\"\n        : selector.name;\n    const cacheKey = `avg_${selectorName}`;\n    if (this.statsCache.has(cacheKey)) {\n      return this.statsCache.get(cacheKey)!;\n    }\n\n    let sum = 0;\n    if (typeof selector === \"function\") {\n      // For function selectors, calculate sum directly\n      sum = this.results.reduce((acc: number, roll: DiceResult) => {\n        const value = selector(roll);\n        if (typeof value !== \"number\" || isNaN(value)) {\n          throw new MonteCarloError(`Invalid selector result: ${value}`);\n        }\n        return acc + value;\n      }, 0);\n    } else {\n      // For named selectors, use running stats\n      switch (selector.name) {\n        case \"successes\":\n          sum = this.runningStats.sumSuccesses;\n          break;\n        case \"advantages\":\n          sum = this.runningStats.sumAdvantages;\n          break;\n        case \"triumphs\":\n          sum = this.runningStats.sumTriumphs;\n          break;\n        case \"failures\":\n          sum = this.runningStats.sumFailures;\n          break;\n        case \"threats\":\n          sum = this.runningStats.sumThreats;\n          break;\n        case \"despair\":\n          sum = this.runningStats.sumDespair;\n          break;\n        case \"lightSide\":\n          sum = this.runningStats.sumLightSide;\n          break;\n        case \"darkSide\":\n          sum = this.runningStats.sumDarkSide;\n          break;\n        default:\n          throw new MonteCarloError(`Unknown selector: ${selector.name}`);\n      }\n    }\n\n    const avg = sum / this.iterations;\n    this.statsCache.set(cacheKey, avg);\n    return avg;\n  }\n\n  private standardDeviation(\n    selector: ((roll: DiceResult) => number) | { name: string },\n  ): number {\n    const selectorName =\n      typeof selector === \"function\"\n        ? selector.name || \"custom\"\n        : selector.name;\n    const cacheKey = `std_${selectorName}`;\n    if (this.statsCache.has(cacheKey)) {\n      return this.statsCache.get(cacheKey)!;\n    }\n\n    const avg = this.average(selector);\n    let squareSum = 0;\n\n    if (typeof selector === \"function\") {\n      // For function selectors, calculate square sum directly\n      squareSum = this.results.reduce((acc: number, roll: DiceResult) => {\n        const value = selector(roll);\n        if (typeof value !== \"number\" || isNaN(value)) {\n          throw new MonteCarloError(`Invalid selector result: ${value}`);\n        }\n        return acc + value * value;\n      }, 0);\n    } else {\n      // For named selectors, use running stats\n      switch (selector.name) {\n        case \"successes\":\n          squareSum = this.runningStats.sumSquaredSuccesses;\n          break;\n        case \"advantages\":\n          squareSum = this.runningStats.sumSquaredAdvantages;\n          break;\n        case \"threats\":\n          squareSum = this.runningStats.sumSquaredThreats;\n          break;\n        case \"triumphs\":\n          squareSum = this.runningStats.sumSquaredTriumphs;\n          break;\n        case \"failures\":\n          squareSum = this.runningStats.sumSquaredFailures;\n          break;\n        case \"despair\":\n          squareSum = this.runningStats.sumSquaredDespair;\n          break;\n        case \"lightSide\":\n          squareSum = this.runningStats.sumSquaredLightSide;\n          break;\n        case \"darkSide\":\n          squareSum = this.runningStats.sumSquaredDarkSide;\n          break;\n        default:\n          throw new MonteCarloError(`Unknown selector: ${selector.name}`);\n      }\n    }\n\n    const stdDev = Math.sqrt(Math.abs(squareSum / this.iterations - avg * avg));\n    this.statsCache.set(cacheKey, stdDev);\n    return stdDev;\n  }\n\n  private resetRunningStats(): void {\n    this.runningStats = {\n      successCount: 0,\n      criticalSuccessCount: 0,\n      criticalFailureCount: 0,\n      netPositiveCount: 0,\n      sumSuccesses: 0,\n      sumAdvantages: 0,\n      sumTriumphs: 0,\n      sumFailures: 0,\n      sumThreats: 0,\n      sumDespair: 0,\n      sumLightSide: 0,\n      sumDarkSide: 0,\n      sumSquaredSuccesses: 0,\n      sumSquaredAdvantages: 0,\n      sumSquaredThreats: 0,\n      sumSquaredFailures: 0,\n      sumSquaredDespair: 0,\n      sumSquaredLightSide: 0,\n      sumSquaredDarkSide: 0,\n      sumSquaredTriumphs: 0,\n    };\n  }\n\n  private resetModifierStats(): void {\n    this.modifierStats = {\n      automaticSymbolContribution: {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despairs: 0,\n        lightSide: 0,\n        darkSide: 0,\n      },\n      rolledSymbolContribution: {\n        successes: 0,\n        failures: 0,\n        advantages: 0,\n        threats: 0,\n        triumphs: 0,\n        despairs: 0,\n        lightSide: 0,\n        darkSide: 0,\n      },\n      upgradeImpact: {\n        abilityUpgrades: 0,\n        difficultyUpgrades: 0,\n        proficiencyDowngrades: 0,\n        challengeDowngrades: 0,\n      },\n    };\n  }\n\n  private trackModifierContribution(result: DiceResult): void {\n    if (!this.modifiers) return;\n\n    // Get the automatic symbols from the dice pool (these are already included in the result)\n    // The DicePool modifiers are applied by the dice library, so the result already includes them\n    const poolModifiers = this.applyModifiers(this.dicePool);\n    const autoSuccesses = poolModifiers.automaticSuccesses || 0;\n    const autoFailures = poolModifiers.automaticFailures || 0;\n    const autoAdvantages = poolModifiers.automaticAdvantages || 0;\n    const autoThreats = poolModifiers.automaticThreats || 0;\n    const autoTriumphs = poolModifiers.automaticTriumphs || 0;\n    const autoDespairs = poolModifiers.automaticDespairs || 0;\n    const autoLightSide = poolModifiers.automaticLightSide || 0;\n    const autoDarkSide = poolModifiers.automaticDarkSide || 0;\n\n    // Track automatic symbol contributions\n    this.modifierStats.automaticSymbolContribution.successes += autoSuccesses;\n    this.modifierStats.automaticSymbolContribution.failures += autoFailures;\n    this.modifierStats.automaticSymbolContribution.advantages += autoAdvantages;\n    this.modifierStats.automaticSymbolContribution.threats += autoThreats;\n    this.modifierStats.automaticSymbolContribution.triumphs += autoTriumphs;\n    this.modifierStats.automaticSymbolContribution.despairs += autoDespairs;\n    this.modifierStats.automaticSymbolContribution.lightSide += autoLightSide;\n    this.modifierStats.automaticSymbolContribution.darkSide += autoDarkSide;\n\n    // Track rolled symbol contributions (total result minus automatic symbols)\n    // The result from roll() already includes automatic symbols, so we subtract them\n    this.modifierStats.rolledSymbolContribution.successes += Math.max(\n      0,\n      result.successes - autoSuccesses,\n    );\n    this.modifierStats.rolledSymbolContribution.failures += Math.max(\n      0,\n      result.failures - autoFailures,\n    );\n    this.modifierStats.rolledSymbolContribution.advantages += Math.max(\n      0,\n      result.advantages - autoAdvantages,\n    );\n    this.modifierStats.rolledSymbolContribution.threats += Math.max(\n      0,\n      result.threats - autoThreats,\n    );\n    this.modifierStats.rolledSymbolContribution.triumphs += Math.max(\n      0,\n      result.triumphs - autoTriumphs,\n    );\n    this.modifierStats.rolledSymbolContribution.despairs += Math.max(\n      0,\n      result.despair - autoDespairs,\n    );\n    this.modifierStats.rolledSymbolContribution.lightSide += Math.max(\n      0,\n      result.lightSide - autoLightSide,\n    );\n    this.modifierStats.rolledSymbolContribution.darkSide += Math.max(\n      0,\n      result.darkSide - autoDarkSide,\n    );\n  }\n\n  private updateHistogram(result: DiceResult): void {\n    // Update net successes with direct array access\n    const netSuccesses = result.successes - result.failures;\n    this.histogram.netSuccesses[netSuccesses] =\n      (this.histogram.netSuccesses[netSuccesses] || 0) + 1;\n\n    // Update net advantages with direct array access\n    const netAdvantages = result.advantages - result.threats;\n    this.histogram.netAdvantages[netAdvantages] =\n      (this.histogram.netAdvantages[netAdvantages] || 0) + 1;\n\n    // Update other histograms with direct array access\n    this.histogram.triumphs[result.triumphs] =\n      (this.histogram.triumphs[result.triumphs] || 0) + 1;\n    this.histogram.despairs[result.despair] =\n      (this.histogram.despairs[result.despair] || 0) + 1;\n    this.histogram.lightSide[result.lightSide] =\n      (this.histogram.lightSide[result.lightSide] || 0) + 1;\n    this.histogram.darkSide[result.darkSide] =\n      (this.histogram.darkSide[result.darkSide] || 0) + 1;\n\n    // Update running statistics\n    this.runningStats.sumSuccesses += result.successes;\n    this.runningStats.sumAdvantages += result.advantages;\n    this.runningStats.sumTriumphs += result.triumphs;\n    this.runningStats.sumFailures += result.failures;\n    this.runningStats.sumThreats += result.threats;\n    this.runningStats.sumDespair += result.despair;\n    this.runningStats.sumLightSide += result.lightSide;\n    this.runningStats.sumDarkSide += result.darkSide;\n    this.runningStats.sumSquaredSuccesses +=\n      result.successes * result.successes;\n    this.runningStats.sumSquaredAdvantages +=\n      result.advantages * result.advantages;\n    this.runningStats.sumSquaredThreats += result.threats * result.threats;\n    this.runningStats.sumSquaredFailures += result.failures * result.failures;\n    this.runningStats.sumSquaredDespair += result.despair * result.despair;\n    this.runningStats.sumSquaredLightSide +=\n      result.lightSide * result.lightSide;\n    this.runningStats.sumSquaredDarkSide += result.darkSide * result.darkSide;\n    this.runningStats.sumSquaredTriumphs += result.triumphs * result.triumphs;\n\n    if (netSuccesses > 0) {\n      this.runningStats.successCount++;\n      if (netAdvantages > 0) {\n        this.runningStats.netPositiveCount++;\n      }\n    }\n    if (result.triumphs > 0) this.runningStats.criticalSuccessCount++;\n    if (result.despair > 0) this.runningStats.criticalFailureCount++;\n  }\n\n  public simulate(): MonteCarloResult {\n    try {\n      this.resetHistogram();\n      this.resetRunningStats();\n      this.resetModifierStats();\n      this.statsCache.clear();\n      this.results = [];\n\n      // Apply modifiers to create the modified pool\n      const modifiedPool = this.applyModifiers(this.dicePool);\n\n      // Run simulations and update histograms in a single pass\n      for (let i = 0; i < this.iterations; i++) {\n        const rollResult = roll(modifiedPool);\n        this.results.push(rollResult.summary);\n        this.updateHistogram(rollResult.summary);\n        this.trackModifierContribution(rollResult.summary);\n      }\n\n      // Calculate probabilities using running statistics\n      const successProbability =\n        this.runningStats.successCount / this.iterations;\n      const criticalSuccessProbability =\n        this.runningStats.criticalSuccessCount / this.iterations;\n      const criticalFailureProbability =\n        this.runningStats.criticalFailureCount / this.iterations;\n      const netPositiveProbability =\n        this.runningStats.netPositiveCount / this.iterations;\n\n      // Calculate averages using running statistics\n      const averages = {\n        successes: this.runningStats.sumSuccesses / this.iterations,\n        advantages: this.runningStats.sumAdvantages / this.iterations,\n        triumphs: this.runningStats.sumTriumphs / this.iterations,\n        failures: this.runningStats.sumFailures / this.iterations,\n        threats: this.runningStats.sumThreats / this.iterations,\n        despair: this.runningStats.sumDespair / this.iterations,\n        lightSide: this.runningStats.sumLightSide / this.iterations,\n        darkSide: this.runningStats.sumDarkSide / this.iterations,\n      };\n\n      // Calculate standard deviations using running statistics\n      const standardDeviations = {\n        successes: Math.sqrt(\n          this.runningStats.sumSquaredSuccesses / this.iterations -\n            averages.successes * averages.successes,\n        ),\n        advantages: Math.sqrt(\n          this.runningStats.sumSquaredAdvantages / this.iterations -\n            averages.advantages * averages.advantages,\n        ),\n        triumphs: Math.sqrt(\n          this.runningStats.sumSquaredTriumphs / this.iterations -\n            averages.triumphs * averages.triumphs,\n        ),\n        failures: Math.sqrt(\n          this.runningStats.sumSquaredFailures / this.iterations -\n            averages.failures * averages.failures,\n        ),\n        threats: Math.sqrt(\n          this.runningStats.sumSquaredThreats / this.iterations -\n            averages.threats * averages.threats,\n        ),\n        despair: Math.sqrt(\n          this.runningStats.sumSquaredDespair / this.iterations -\n            averages.despair * averages.despair,\n        ),\n        lightSide: Math.sqrt(\n          this.runningStats.sumSquaredLightSide / this.iterations -\n            averages.lightSide * averages.lightSide,\n        ),\n        darkSide: Math.sqrt(\n          this.runningStats.sumSquaredDarkSide / this.iterations -\n            averages.darkSide * averages.darkSide,\n        ),\n      };\n\n      // Calculate medians using histogram data\n      const medians = {\n        successes: this.calculateMedianFromHistogram(\n          this.histogram.netSuccesses,\n        ),\n        advantages: this.calculateMedianFromHistogram(\n          this.histogram.netAdvantages,\n        ),\n        triumphs: this.calculateMedianFromHistogram(this.histogram.triumphs),\n        failures: this.calculateMedianFromHistogram(this.histogram.despairs),\n        threats: this.calculateMedianFromHistogram(\n          this.histogram.netAdvantages,\n        ),\n        despair: this.calculateMedianFromHistogram(this.histogram.despairs),\n        lightSide: this.calculateMedianFromHistogram(this.histogram.lightSide),\n        darkSide: this.calculateMedianFromHistogram(this.histogram.darkSide),\n      };\n\n      // Calculate analysis for each histogram category\n      const analysis = {\n        netSuccesses: this.analyzeDistribution(\n          this.histogram.netSuccesses,\n          this.iterations,\n        ),\n        netAdvantages: this.analyzeDistribution(\n          this.histogram.netAdvantages,\n          this.iterations,\n        ),\n        triumphs: this.analyzeDistribution(\n          this.histogram.triumphs,\n          this.iterations,\n        ),\n        despairs: this.analyzeDistribution(\n          this.histogram.despairs,\n          this.iterations,\n        ),\n        lightSide: this.analyzeDistribution(\n          this.histogram.lightSide,\n          this.iterations,\n        ),\n        darkSide: this.analyzeDistribution(\n          this.histogram.darkSide,\n          this.iterations,\n        ),\n      };\n\n      const result: MonteCarloResult = {\n        averages,\n        medians,\n        standardDeviations,\n        successProbability,\n        criticalSuccessProbability,\n        criticalFailureProbability,\n        netPositiveProbability,\n        histogram: this.histogram,\n        analysis,\n      };\n\n      // Add modifier analysis if modifiers were used\n      if (this.modifiers) {\n        // Calculate average contributions\n        const iterations = this.iterations;\n        result.modifierAnalysis = {\n          automaticSymbolContribution: {\n            successes:\n              this.modifierStats.automaticSymbolContribution.successes /\n              iterations,\n            failures:\n              this.modifierStats.automaticSymbolContribution.failures /\n              iterations,\n            advantages:\n              this.modifierStats.automaticSymbolContribution.advantages /\n              iterations,\n            threats:\n              this.modifierStats.automaticSymbolContribution.threats /\n              iterations,\n            triumphs:\n              this.modifierStats.automaticSymbolContribution.triumphs /\n              iterations,\n            despairs:\n              this.modifierStats.automaticSymbolContribution.despairs /\n              iterations,\n            lightSide:\n              this.modifierStats.automaticSymbolContribution.lightSide /\n              iterations,\n            darkSide:\n              this.modifierStats.automaticSymbolContribution.darkSide /\n              iterations,\n          },\n          rolledSymbolContribution: {\n            successes:\n              this.modifierStats.rolledSymbolContribution.successes /\n              iterations,\n            failures:\n              this.modifierStats.rolledSymbolContribution.failures / iterations,\n            advantages:\n              this.modifierStats.rolledSymbolContribution.advantages /\n              iterations,\n            threats:\n              this.modifierStats.rolledSymbolContribution.threats / iterations,\n            triumphs:\n              this.modifierStats.rolledSymbolContribution.triumphs / iterations,\n            despairs:\n              this.modifierStats.rolledSymbolContribution.despairs / iterations,\n            lightSide:\n              this.modifierStats.rolledSymbolContribution.lightSide /\n              iterations,\n            darkSide:\n              this.modifierStats.rolledSymbolContribution.darkSide / iterations,\n          },\n          upgradeImpact: this.modifierStats.upgradeImpact,\n        };\n      }\n\n      return result;\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new MonteCarloError(`Simulation failed: ${error.message}`);\n      }\n      throw new MonteCarloError(\"Simulation failed with unknown error\");\n    }\n  }\n\n  private resetHistogram(): void {\n    this.histogram = {\n      netSuccesses: {},\n      netAdvantages: {},\n      triumphs: {},\n      despairs: {},\n      lightSide: {},\n      darkSide: {},\n    };\n  }\n\n  private calculateMedianFromHistogram(histogram: {\n    [key: number]: number;\n  }): number {\n    const entries = Object.entries(histogram)\n      .map(([value, count]) => ({ value: parseInt(value), count }))\n      .sort((a, b) => a.value - b.value);\n\n    if (entries.length === 0) {\n      return 0;\n    }\n\n    let runningCount = 0;\n    const targetCount = this.iterations / 2;\n\n    for (const { value, count } of entries) {\n      runningCount += count;\n      if (runningCount >= targetCount) {\n        return value;\n      }\n    }\n\n    return entries[entries.length - 1].value;\n  }\n\n  private findModes(histogram: { [key: number]: number }): number[] {\n    const entries = Object.entries(histogram);\n    if (entries.length === 0) return [];\n\n    const maxCount = Math.max(...entries.map(([, count]) => count));\n    return entries\n      .filter(([, count]) => count === maxCount)\n      .map(([value]) => parseInt(value));\n  }\n\n  private calculatePercentiles(\n    histogram: { [key: number]: number },\n    totalCount: number,\n  ): { [key: number]: number } {\n    const sortedEntries = Object.entries(histogram)\n      .map(([value, count]) => ({ value: parseInt(value), count }))\n      .sort((a, b) => a.value - b.value);\n\n    if (sortedEntries.length === 0) {\n      return {};\n    }\n\n    const percentiles: { [key: number]: number } = {};\n    let runningCount = 0;\n\n    // Calculate percentiles at specific points\n    const targetPercentiles = [25, 50, 75, 90];\n    let currentTargetIndex = 0;\n\n    // Find the value for each percentile\n    for (const { value, count } of sortedEntries) {\n      runningCount += count;\n      const currentPercentile = (runningCount / totalCount) * 100;\n\n      // Check if we've passed any target percentiles\n      while (\n        currentTargetIndex < targetPercentiles.length &&\n        currentPercentile >= targetPercentiles[currentTargetIndex]\n      ) {\n        percentiles[targetPercentiles[currentTargetIndex]] = value;\n        currentTargetIndex++;\n      }\n    }\n\n    // If we haven't reached all target percentiles, use the maximum value\n    const maxValue = sortedEntries[sortedEntries.length - 1].value;\n    while (currentTargetIndex < targetPercentiles.length) {\n      percentiles[targetPercentiles[currentTargetIndex]] = maxValue;\n      currentTargetIndex++;\n    }\n\n    return percentiles;\n  }\n}\n"],
  "mappings": "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",
  "names": ["SYMBOLS", "SUCCESS", "FAILURE", "ADVANTAGE", "THREAT", "TRIUMPH", "DESPAIR", "LIGHT", "DARK", "hints", "description", "cost", "BOOST_DIE_FACES", "successes", "advantages", "SETBACK_DIE_FACES", "failures", "threats", "ABILITY_DIE_FACES", "DIFFICULTY_DIE_FACES", "PROFICIENCY_DIE_FACES", "triumphs", "CHALLENGE_DIE_FACES", "despairs", "FORCE_DIE_FACES", "darkSide", "lightSide", "rollDie", "sides", "Math", "floor", "random", "boostDieResult", "roll", "face", "BOOST_DIE_FACES", "successes", "failures", "advantages", "threats", "triumphs", "despair", "despairs", "lightSide", "darkSide", "setBackDieResult", "SETBACK_DIE_FACES", "abilityDieResult", "ABILITY_DIE_FACES", "difficultyDieResult", "DIFFICULTY_DIE_FACES", "proficiencyDieResult", "PROFICIENCY_DIE_FACES", "challengeDieResult", "CHALLENGE_DIE_FACES", "forceDieResult", "FORCE_DIE_FACES", "pool", "options", "modifiedPool", "upgradeAbility", "upgradesToApply", "currentAbility", "abilityDice", "upgradedDice", "min", "proficiencyDice", "upgradeDifficulty", "currentDifficulty", "difficultyDice", "challengeDice", "downgradeProficiency", "currentProficiency", "downgradesToApply", "downgradeChallenge", "currentChallenge", "boostCount", "_a", "boostDice", "abilityCount", "_b", "proficiencyCount", "_c", "setBackCount", "_d", "setBackDice", "difficultyCount", "_e", "challengeCount", "_f", "forceCount", "_g", "forceDice", "maxDicePerType", "_h", "maxTotalDice", "_j", "sanitizedPool", "max", "exceedsPerTypeLimit", "totalDice", "Error", "throwOnLimitExceeded", "exceeded", "push", "join", "detailedResults", "i", "type", "result", "automaticSymbols", "automaticSuccesses", "automaticFailures", "automaticAdvantages", "automaticThreats", "automaticTriumphs", "automaticDespairs", "automaticLightSide", "automaticDarkSide", "summary", "results", "sums", "reduce", "acc", "curr", "netSuccesses", "netFailures", "netAdvantages", "netThreats", "map", "r", "hints", "applicableHints", "filter", "hint", "cost", "Object", "entries", "some", "symbol", "required", "summaryKey", "toLowerCase", "value", "keys", "length", "parts", "_", "count", "charAt", "toUpperCase", "slice", "description", "i", "a"]
}
